一.初识RXJvava
Observable上游(被观察者) 与 Observer下游(观察者) 通过subscribe建立连接
Disposable 可以切断链接
可以发出next事件、complete事件和error事件,
上游onComplete之后的事件将会继续发送,下游不再继续接受事件.同理onError.
onComplete和onError唯一并且互斥这一点
二.线程调度.
subscribeOn()指定的是上游发送事件的线程, observeOn() 指定的是下游接收事件的线程.
多次指定上游的线程只有第一次指定的有效.
多次指定下游的线程是可以的, 也就是说每调用一次observeOn() , 下游的线程就会切换一次.
eg:
observable.subscribeOn(Schedulers.newThread())     
         .subscribeOn(Schedulers.io())              
         .observeOn(AndroidSchedulers.mainThread()) 
         .observeOn(Schedulers.io())                
         .subscribe(consumer);
RxJava中已经内置了一个容器CompositeDisposable, 每当我们得到一个Disposable时就调用CompositeDisposable.add()将它添加到容器中, 在退出的时候, 调用CompositeDisposable.clear() 即可
三.操作符
Map:
一对一的变换
FlatMap: (相对于Map的不同点在于转化能发送事件)
一对多的变化(一个Observable转换为多个Observables,所有事件封装成另一个Observable)
并不保证事件的顺序,如需顺序采用concatMap操作符.
场景:串联请求
Zip:
多个Observable按顺序组合后发送,(它只发射与发射事件项最少的那个Observable一样多的事件)
场景:需要同时访问多个接口
filter 
过滤事件,true通过下放.
sample 
每隔指定的时间就从上游中取出任意一个事件发送给下游. 

四.背压Backpressure
原因:上下游流速不均衡导致
同步订阅:当上游没发送一个事件,下游接收处理完后,才能接着发送下一个事件.
反之异步订阅无需等待接收处理. 
传统解决方式:
一.是从数量上进行治理, 减少发送进水缸里的事件
二.是从速度上进行治理, 减缓事件发送进水缸的速度

五.初识Flowable/Subscriber:
Subscription对比Dispose.
Subscription 多了一个request(Long g)方法,用于指定下游能处理事件的能力.
BackpressureStrategy.ERR 超过处理能力直接抛异常.
.BUFFER 无限大,会报OOM.
.Drop 直接把存不下的事件丢弃.
.Latest 只保留最新的事件.


